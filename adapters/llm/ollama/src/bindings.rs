// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod ai_messenger {
    pub mod llm {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// Role of a message in the conversation
            #[derive(Clone)]
            pub enum Role {
                System,
                User,
                Assistant,
                Function,
                Tool,
                /// For roles not covered by standard types
                Other(_rt::String),
            }
            impl ::core::fmt::Debug for Role {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        Role::System => f.debug_tuple("Role::System").finish(),
                        Role::User => f.debug_tuple("Role::User").finish(),
                        Role::Assistant => f.debug_tuple("Role::Assistant").finish(),
                        Role::Function => f.debug_tuple("Role::Function").finish(),
                        Role::Tool => f.debug_tuple("Role::Tool").finish(),
                        Role::Other(e) => f.debug_tuple("Role::Other").field(e).finish(),
                    }
                }
            }
            /// A single message in a conversation
            #[derive(Clone)]
            pub struct Message {
                pub role: Role,
                pub content: _rt::String,
            }
            impl ::core::fmt::Debug for Message {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Message")
                        .field("role", &self.role)
                        .field("content", &self.content)
                        .finish()
                }
            }
            /// Reason why generation finished
            #[derive(Clone)]
            pub enum FinishReason {
                Stop,
                Length,
                ContentFilter,
                /// For reasons not covered by standard types
                Other(_rt::String),
            }
            impl ::core::fmt::Debug for FinishReason {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        FinishReason::Stop => {
                            f.debug_tuple("FinishReason::Stop").finish()
                        }
                        FinishReason::Length => {
                            f.debug_tuple("FinishReason::Length").finish()
                        }
                        FinishReason::ContentFilter => {
                            f.debug_tuple("FinishReason::ContentFilter").finish()
                        }
                        FinishReason::Other(e) => {
                            f.debug_tuple("FinishReason::Other").field(e).finish()
                        }
                    }
                }
            }
            /// Request for LLM chat completion
            #[derive(Clone)]
            pub struct ChatRequest {
                /// Array of messages in the conversation
                pub messages: _rt::Vec<Message>,
                /// Model identifier (provider-specific)
                pub model: _rt::String,
                /// Maximum number of completion tokens to generate
                pub max_completion_tokens: Option<u32>,
                /// Sampling temperature (0.0 to 2.0, typically 0.0-1.0)
                pub temperature: Option<f32>,
                /// Top-p sampling parameter (0.0 to 1.0)
                pub top_p: Option<f32>,
                /// Whether to stream the response (providers may reject if unsupported)
                pub enable_streaming: Option<bool>,
                /// Stop sequences
                pub stop: Option<_rt::Vec<_rt::String>>,
                /// Random seed for deterministic outputs
                pub seed: Option<u32>,
                /// User identifier for tracking
                pub user: Option<_rt::String>,
                /// Provider-specific parameters as JSON string
                pub provider_params: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for ChatRequest {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ChatRequest")
                        .field("messages", &self.messages)
                        .field("model", &self.model)
                        .field("max-completion-tokens", &self.max_completion_tokens)
                        .field("temperature", &self.temperature)
                        .field("top-p", &self.top_p)
                        .field("enable-streaming", &self.enable_streaming)
                        .field("stop", &self.stop)
                        .field("seed", &self.seed)
                        .field("user", &self.user)
                        .field("provider-params", &self.provider_params)
                        .finish()
                }
            }
            /// Token usage statistics
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct Usage {
                pub prompt_tokens: u32,
                pub completion_tokens: u32,
                pub total_tokens: u32,
            }
            impl ::core::fmt::Debug for Usage {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("Usage")
                        .field("prompt-tokens", &self.prompt_tokens)
                        .field("completion-tokens", &self.completion_tokens)
                        .field("total-tokens", &self.total_tokens)
                        .finish()
                }
            }
            /// Response from LLM chat completion
            #[derive(Clone)]
            pub struct ChatResponse {
                /// Generated content
                pub content: _rt::String,
                /// Model that generated the response
                pub model: _rt::String,
                /// Reason why generation finished
                pub finish_reason: Option<FinishReason>,
                /// Token usage statistics
                pub usage: Option<Usage>,
            }
            impl ::core::fmt::Debug for ChatResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ChatResponse")
                        .field("content", &self.content)
                        .field("model", &self.model)
                        .field("finish-reason", &self.finish_reason)
                        .field("usage", &self.usage)
                        .finish()
                }
            }
            /// HTTP request configuration
            #[derive(Clone)]
            pub struct HttpConfig {
                /// Full URL to send the request to
                pub url: _rt::String,
                /// HTTP headers as key-value pairs
                pub headers: _rt::Vec<(_rt::String, _rt::String)>,
                /// Request body as JSON string
                pub body: _rt::String,
            }
            impl ::core::fmt::Debug for HttpConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("HttpConfig")
                        .field("url", &self.url)
                        .field("headers", &self.headers)
                        .field("body", &self.body)
                        .finish()
                }
            }
            /// HTTP response from the provider API
            #[derive(Clone)]
            pub struct HttpResponse {
                /// HTTP status code
                pub status_code: u16,
                /// Response headers as key-value pairs
                pub headers: _rt::Vec<(_rt::String, _rt::String)>,
                /// Response body as string
                pub body: _rt::String,
            }
            impl ::core::fmt::Debug for HttpResponse {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("HttpResponse")
                        .field("status-code", &self.status_code)
                        .field("headers", &self.headers)
                        .field("body", &self.body)
                        .finish()
                }
            }
            /// Streaming chunk for real-time responses
            #[derive(Clone)]
            pub struct StreamChunk {
                /// Sequence number for chunk ordering/debugging
                pub sequence: u64,
                /// Partial content (empty if this is metadata-only chunk)
                pub content: _rt::String,
                /// Whether this is the final chunk
                pub is_final: bool,
                /// Usage statistics (typically only in final chunk)
                pub usage: Option<Usage>,
                /// Finish reason (typically only in final chunk)
                pub finish_reason: Option<FinishReason>,
            }
            impl ::core::fmt::Debug for StreamChunk {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("StreamChunk")
                        .field("sequence", &self.sequence)
                        .field("content", &self.content)
                        .field("is-final", &self.is_final)
                        .field("usage", &self.usage)
                        .field("finish-reason", &self.finish_reason)
                        .finish()
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod ai_messenger {
        pub mod llm {
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod llm {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type ChatRequest = super::super::super::super::ai_messenger::llm::types::ChatRequest;
                pub type ChatResponse = super::super::super::super::ai_messenger::llm::types::ChatResponse;
                pub type HttpConfig = super::super::super::super::ai_messenger::llm::types::HttpConfig;
                pub type HttpResponse = super::super::super::super::ai_messenger::llm::types::HttpResponse;
                pub type StreamChunk = super::super::super::super::ai_messenger::llm::types::StreamChunk;
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_prepare_request_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base10 = l0;
                    let len10 = l1;
                    let mut result10 = _rt::Vec::with_capacity(len10);
                    for i in 0..len10 {
                        let base = base10
                            .add(i * (5 * ::core::mem::size_of::<*const u8>()));
                        let e10 = {
                            let l2 = i32::from(*base.add(0).cast::<u8>());
                            use super::super::super::super::ai_messenger::llm::types::Role as V6;
                            let v6 = match l2 {
                                0 => V6::System,
                                1 => V6::User,
                                2 => V6::Assistant,
                                3 => V6::Function,
                                4 => V6::Tool,
                                n => {
                                    debug_assert_eq!(n, 5, "invalid enum discriminant");
                                    let e6 = {
                                        let l3 = *base
                                            .add(::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l4 = *base
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len5 = l4;
                                        let bytes5 = _rt::Vec::from_raw_parts(
                                            l3.cast(),
                                            len5,
                                            len5,
                                        );
                                        _rt::string_lift(bytes5)
                                    };
                                    V6::Other(e6)
                                }
                            };
                            let l7 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *base
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len9 = l8;
                            let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                            super::super::super::super::ai_messenger::llm::types::Message {
                                role: v6,
                                content: _rt::string_lift(bytes9),
                            }
                        };
                        result10.push(e10);
                    }
                    _rt::cabi_dealloc(
                        base10,
                        len10 * (5 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l11 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<*mut u8>();
                    let l12 = *arg0
                        .add(3 * ::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len13 = l12;
                    let bytes13 = _rt::Vec::from_raw_parts(l11.cast(), len13, len13);
                    let l14 = i32::from(
                        *arg0.add(4 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l16 = i32::from(
                        *arg0
                            .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l18 = i32::from(
                        *arg0
                            .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l20 = i32::from(
                        *arg0
                            .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l22 = i32::from(
                        *arg0
                            .add(24 + 5 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l29 = i32::from(
                        *arg0
                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l31 = i32::from(
                        *arg0
                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let l35 = i32::from(
                        *arg0
                            .add(32 + 11 * ::core::mem::size_of::<*const u8>())
                            .cast::<u8>(),
                    );
                    let result39 = T::prepare_request(super::super::super::super::ai_messenger::llm::types::ChatRequest {
                        messages: result10,
                        model: _rt::string_lift(bytes13),
                        max_completion_tokens: match l14 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l15 = *arg0
                                        .add(4 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>();
                                    l15 as u32
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        temperature: match l16 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l17 = *arg0
                                        .add(12 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<f32>();
                                    l17
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        top_p: match l18 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l19 = *arg0
                                        .add(20 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<f32>();
                                    l19
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        enable_streaming: match l20 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l21 = i32::from(
                                        *arg0
                                            .add(25 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    _rt::bool_lift(l21 as u8)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        stop: match l22 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l23 = *arg0
                                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l24 = *arg0
                                        .add(24 + 7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base28 = l23;
                                    let len28 = l24;
                                    let mut result28 = _rt::Vec::with_capacity(len28);
                                    for i in 0..len28 {
                                        let base = base28
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        let e28 = {
                                            let l25 = *base.add(0).cast::<*mut u8>();
                                            let l26 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len27 = l26;
                                            let bytes27 = _rt::Vec::from_raw_parts(
                                                l25.cast(),
                                                len27,
                                                len27,
                                            );
                                            _rt::string_lift(bytes27)
                                        };
                                        result28.push(e28);
                                    }
                                    _rt::cabi_dealloc(
                                        base28,
                                        len28 * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    result28
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        seed: match l29 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l30 = *arg0
                                        .add(28 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>();
                                    l30 as u32
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        user: match l31 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l32 = *arg0
                                        .add(32 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(32 + 10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len34 = l33;
                                    let bytes34 = _rt::Vec::from_raw_parts(
                                        l32.cast(),
                                        len34,
                                        len34,
                                    );
                                    _rt::string_lift(bytes34)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        provider_params: match l35 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l36 = *arg0
                                        .add(32 + 12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l37 = *arg0
                                        .add(32 + 13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let len38 = l37;
                                    let bytes38 = _rt::Vec::from_raw_parts(
                                        l36.cast(),
                                        len38,
                                        len38,
                                    );
                                    _rt::string_lift(bytes38)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    });
                    _rt::cabi_dealloc(
                        arg0,
                        32 + 14 * ::core::mem::size_of::<*const u8>(),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let ptr40 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result39 {
                        Ok(e) => {
                            *ptr40.add(0).cast::<u8>() = (0i32) as u8;
                            let super::super::super::super::ai_messenger::llm::types::HttpConfig {
                                url: url41,
                                headers: headers41,
                                body: body41,
                            } = e;
                            let vec42 = (url41.into_bytes()).into_boxed_slice();
                            let ptr42 = vec42.as_ptr().cast::<u8>();
                            let len42 = vec42.len();
                            ::core::mem::forget(vec42);
                            *ptr40
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len42;
                            *ptr40
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr42.cast_mut();
                            let vec46 = headers41;
                            let len46 = vec46.len();
                            let layout46 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec46.len() * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result46 = if layout46.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout46).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout46);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec46.into_iter().enumerate() {
                                let base = result46
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let (t43_0, t43_1) = e;
                                    let vec44 = (t43_0.into_bytes()).into_boxed_slice();
                                    let ptr44 = vec44.as_ptr().cast::<u8>();
                                    let len44 = vec44.len();
                                    ::core::mem::forget(vec44);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len44;
                                    *base.add(0).cast::<*mut u8>() = ptr44.cast_mut();
                                    let vec45 = (t43_1.into_bytes()).into_boxed_slice();
                                    let ptr45 = vec45.as_ptr().cast::<u8>();
                                    let len45 = vec45.len();
                                    ::core::mem::forget(vec45);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len45;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr45.cast_mut();
                                }
                            }
                            *ptr40
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len46;
                            *ptr40
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result46;
                            let vec47 = (body41.into_bytes()).into_boxed_slice();
                            let ptr47 = vec47.as_ptr().cast::<u8>();
                            let len47 = vec47.len();
                            ::core::mem::forget(vec47);
                            *ptr40
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len47;
                            *ptr40
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr47.cast_mut();
                        }
                        Err(e) => {
                            *ptr40.add(0).cast::<u8>() = (1i32) as u8;
                            let vec48 = (e.into_bytes()).into_boxed_slice();
                            let ptr48 = vec48.as_ptr().cast::<u8>();
                            let len48 = vec48.len();
                            ::core::mem::forget(vec48);
                            *ptr40
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len48;
                            *ptr40
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr48.cast_mut();
                        }
                    };
                    ptr40
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_prepare_request<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base9 = l3;
                            let len9 = l4;
                            for i in 0..len9 {
                                let base = base9
                                    .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l5 = *base.add(0).cast::<*mut u8>();
                                    let l6 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                    let l7 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l8 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base9,
                                len9 * (4 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l10 = *arg0
                                .add(5 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l11 = *arg0
                                .add(6 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l10, l11, 1);
                        }
                        _ => {
                            let l12 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l13 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l12, l13, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_parse_response_cabi<T: Guest>(
                    arg0: i32,
                    arg1: *mut u8,
                    arg2: usize,
                    arg3: *mut u8,
                    arg4: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let base6 = arg1;
                    let len6 = arg2;
                    let mut result6 = _rt::Vec::with_capacity(len6);
                    for i in 0..len6 {
                        let base = base6
                            .add(i * (4 * ::core::mem::size_of::<*const u8>()));
                        let e6 = {
                            let l0 = *base.add(0).cast::<*mut u8>();
                            let l1 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len2 = l1;
                            let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                            let l3 = *base
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *base
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len5 = l4;
                            let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                            (_rt::string_lift(bytes2), _rt::string_lift(bytes5))
                        };
                        result6.push(e6);
                    }
                    _rt::cabi_dealloc(
                        base6,
                        len6 * (4 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let len7 = arg4;
                    let bytes7 = _rt::Vec::from_raw_parts(arg3.cast(), len7, len7);
                    let result8 = T::parse_response(super::super::super::super::ai_messenger::llm::types::HttpResponse {
                        status_code: arg0 as u16,
                        headers: result6,
                        body: _rt::string_lift(bytes7),
                    });
                    let ptr9 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result8 {
                        Ok(e) => {
                            *ptr9.add(0).cast::<u8>() = (0i32) as u8;
                            let super::super::super::super::ai_messenger::llm::types::ChatResponse {
                                content: content10,
                                model: model10,
                                finish_reason: finish_reason10,
                                usage: usage10,
                            } = e;
                            let vec11 = (content10.into_bytes()).into_boxed_slice();
                            let ptr11 = vec11.as_ptr().cast::<u8>();
                            let len11 = vec11.len();
                            ::core::mem::forget(vec11);
                            *ptr9
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len11;
                            *ptr9
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr11.cast_mut();
                            let vec12 = (model10.into_bytes()).into_boxed_slice();
                            let ptr12 = vec12.as_ptr().cast::<u8>();
                            let len12 = vec12.len();
                            ::core::mem::forget(vec12);
                            *ptr9
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len12;
                            *ptr9
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr12.cast_mut();
                            match finish_reason10 {
                                Some(e) => {
                                    *ptr9
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    use super::super::super::super::ai_messenger::llm::types::FinishReason as V14;
                                    match e {
                                        V14::Stop => {
                                            *ptr9
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                        V14::Length => {
                                            *ptr9
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                        }
                                        V14::ContentFilter => {
                                            *ptr9
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (2i32) as u8;
                                        }
                                        V14::Other(e) => {
                                            *ptr9
                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (3i32) as u8;
                                            let vec13 = (e.into_bytes()).into_boxed_slice();
                                            let ptr13 = vec13.as_ptr().cast::<u8>();
                                            let len13 = vec13.len();
                                            ::core::mem::forget(vec13);
                                            *ptr9
                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len13;
                                            *ptr9
                                                .add(7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr13.cast_mut();
                                        }
                                    }
                                }
                                None => {
                                    *ptr9
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            match usage10 {
                                Some(e) => {
                                    *ptr9
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::ai_messenger::llm::types::Usage {
                                        prompt_tokens: prompt_tokens15,
                                        completion_tokens: completion_tokens15,
                                        total_tokens: total_tokens15,
                                    } = e;
                                    *ptr9
                                        .add(4 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(prompt_tokens15);
                                    *ptr9
                                        .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(completion_tokens15);
                                    *ptr9
                                        .add(12 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(total_tokens15);
                                }
                                None => {
                                    *ptr9
                                        .add(9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr9.add(0).cast::<u8>() = (1i32) as u8;
                            let vec16 = (e.into_bytes()).into_boxed_slice();
                            let ptr16 = vec16.as_ptr().cast::<u8>();
                            let len16 = vec16.len();
                            ::core::mem::forget(vec16);
                            *ptr9
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len16;
                            *ptr9
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr16.cast_mut();
                        }
                    };
                    ptr9
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_parse_response<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = *arg0
                                .add(3 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l4 = *arg0
                                .add(4 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l3, l4, 1);
                            let l5 = i32::from(
                                *arg0
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l5 {
                                0 => {}
                                _ => {
                                    let l6 = i32::from(
                                        *arg0
                                            .add(6 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l6 {
                                        0 => {}
                                        1 => {}
                                        2 => {}
                                        _ => {
                                            let l7 = *arg0
                                                .add(7 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l8 = *arg0
                                                .add(8 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l7, l8, 1);
                                        }
                                    }
                                }
                            }
                        }
                        _ => {
                            let l9 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l10 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l9, l10, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_parse_stream_chunk_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::parse_stream_chunk(_rt::string_lift(bytes0));
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            match e {
                                Some(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::ai_messenger::llm::types::StreamChunk {
                                        sequence: sequence3,
                                        content: content3,
                                        is_final: is_final3,
                                        usage: usage3,
                                        finish_reason: finish_reason3,
                                    } = e;
                                    *ptr2.add(16).cast::<i64>() = _rt::as_i64(sequence3);
                                    let vec4 = (content3.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2
                                        .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr2.add(24).cast::<*mut u8>() = ptr4.cast_mut();
                                    *ptr2
                                        .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match is_final3 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match usage3 {
                                        Some(e) => {
                                            *ptr2
                                                .add(28 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::ai_messenger::llm::types::Usage {
                                                prompt_tokens: prompt_tokens5,
                                                completion_tokens: completion_tokens5,
                                                total_tokens: total_tokens5,
                                            } = e;
                                            *ptr2
                                                .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i32>() = _rt::as_i32(prompt_tokens5);
                                            *ptr2
                                                .add(36 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i32>() = _rt::as_i32(completion_tokens5);
                                            *ptr2
                                                .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<i32>() = _rt::as_i32(total_tokens5);
                                        }
                                        None => {
                                            *ptr2
                                                .add(28 + 2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match finish_reason3 {
                                        Some(e) => {
                                            *ptr2
                                                .add(40 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            use super::super::super::super::ai_messenger::llm::types::FinishReason as V7;
                                            match e {
                                                V7::Stop => {
                                                    *ptr2
                                                        .add(40 + 4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                                V7::Length => {
                                                    *ptr2
                                                        .add(40 + 4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                }
                                                V7::ContentFilter => {
                                                    *ptr2
                                                        .add(40 + 4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (2i32) as u8;
                                                }
                                                V7::Other(e) => {
                                                    *ptr2
                                                        .add(40 + 4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (3i32) as u8;
                                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                                    let len6 = vec6.len();
                                                    ::core::mem::forget(vec6);
                                                    *ptr2
                                                        .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>() = len6;
                                                    *ptr2
                                                        .add(40 + 5 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>() = ptr6.cast_mut();
                                                }
                                            }
                                        }
                                        None => {
                                            *ptr2
                                                .add(40 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                None => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            let vec8 = (e.into_bytes()).into_boxed_slice();
                            let ptr8 = vec8.as_ptr().cast::<u8>();
                            let len8 = vec8.len();
                            ::core::mem::forget(vec8);
                            *ptr2
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *ptr2.add(8).cast::<*mut u8>() = ptr8.cast_mut();
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_parse_stream_chunk<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {}
                                _ => {
                                    let l2 = *arg0.add(24).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                    let l4 = i32::from(
                                        *arg0
                                            .add(40 + 3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l4 {
                                        0 => {}
                                        _ => {
                                            let l5 = i32::from(
                                                *arg0
                                                    .add(40 + 4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            match l5 {
                                                0 => {}
                                                1 => {}
                                                2 => {}
                                                _ => {
                                                    let l6 = *arg0
                                                        .add(40 + 5 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l7 = *arg0
                                                        .add(40 + 6 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    _rt::cabi_dealloc(l6, l7, 1);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        _ => {
                            let l8 = *arg0.add(8).cast::<*mut u8>();
                            let l9 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l8, l9, 1);
                        }
                    }
                }
                pub trait Guest {
                    /// Transform a chat request into HTTP configuration
                    fn prepare_request(
                        request: ChatRequest,
                    ) -> Result<HttpConfig, _rt::String>;
                    /// Parse HTTP response into chat response
                    fn parse_response(
                        response: HttpResponse,
                    ) -> Result<ChatResponse, _rt::String>;
                    /// Parse streaming response chunk
                    fn parse_stream_chunk(
                        chunk: _rt::String,
                    ) -> Result<Option<StreamChunk>, _rt::String>;
                }
                #[doc(hidden)]
                macro_rules! __export_ai_messenger_llm_llm_0_0_1_alpha_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "ai-messenger:llm/llm@0.0.1-alpha#prepare-request")] unsafe
                        extern "C" fn export_prepare_request(arg0 : * mut u8,) -> * mut
                        u8 { unsafe { $($path_to_types)*::
                        _export_prepare_request_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_ai-messenger:llm/llm@0.0.1-alpha#prepare-request")]
                        unsafe extern "C" fn _post_return_prepare_request(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_prepare_request::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "ai-messenger:llm/llm@0.0.1-alpha#parse-response")] unsafe extern
                        "C" fn export_parse_response(arg0 : i32, arg1 : * mut u8, arg2 :
                        usize, arg3 : * mut u8, arg4 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_parse_response_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4) } } #[unsafe (export_name =
                        "cabi_post_ai-messenger:llm/llm@0.0.1-alpha#parse-response")]
                        unsafe extern "C" fn _post_return_parse_response(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_parse_response::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "ai-messenger:llm/llm@0.0.1-alpha#parse-stream-chunk")] unsafe
                        extern "C" fn export_parse_stream_chunk(arg0 : * mut u8, arg1 :
                        usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_parse_stream_chunk_cabi::<$ty > (arg0, arg1) } } #[unsafe
                        (export_name =
                        "cabi_post_ai-messenger:llm/llm@0.0.1-alpha#parse-stream-chunk")]
                        unsafe extern "C" fn _post_return_parse_stream_chunk(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_parse_stream_chunk::<$ty > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_ai_messenger_llm_llm_0_0_1_alpha_cabi;
                #[repr(align(8))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 48 + 6 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 48
                        + 6 * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub use alloc_crate::alloc;
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_llm_adapter_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::ai_messenger::llm::llm::__export_ai_messenger_llm_llm_0_0_1_alpha_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::ai_messenger::llm::llm);
    };
}
#[doc(inline)]
pub(crate) use __export_llm_adapter_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:ai-messenger:llm@0.0.1-alpha:llm-adapter:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1205] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xb3\x08\x01A\x02\x01\
A\x09\x01B\x1d\x01q\x06\x06system\0\0\x04user\0\0\x09assistant\0\0\x08function\0\
\0\x04tool\0\0\x05other\x01s\0\x04\0\x04role\x03\0\0\x01r\x02\x04role\x01\x07con\
tents\x04\0\x07message\x03\0\x02\x01q\x04\x04stop\0\0\x06length\0\0\x0econtent-f\
ilter\0\0\x05other\x01s\0\x04\0\x0dfinish-reason\x03\0\x04\x01p\x03\x01ky\x01kv\x01\
k\x7f\x01ps\x01k\x0a\x01ks\x01r\x0a\x08messages\x06\x05models\x15max-completion-\
tokens\x07\x0btemperature\x08\x05top-p\x08\x10enable-streaming\x09\x04stop\x0b\x04\
seed\x07\x04user\x0c\x0fprovider-params\x0c\x04\0\x0cchat-request\x03\0\x0d\x01r\
\x03\x0dprompt-tokensy\x11completion-tokensy\x0ctotal-tokensy\x04\0\x05usage\x03\
\0\x0f\x01k\x05\x01k\x10\x01r\x04\x07contents\x05models\x0dfinish-reason\x11\x05\
usage\x12\x04\0\x0dchat-response\x03\0\x13\x01o\x02ss\x01p\x15\x01r\x03\x03urls\x07\
headers\x16\x04bodys\x04\0\x0bhttp-config\x03\0\x17\x01r\x03\x0bstatus-code{\x07\
headers\x16\x04bodys\x04\0\x0dhttp-response\x03\0\x19\x01r\x05\x08sequencew\x07c\
ontents\x08is-final\x7f\x05usage\x12\x0dfinish-reason\x11\x04\0\x0cstream-chunk\x03\
\0\x1b\x03\0\"ai-messenger:llm/types@0.0.1-alpha\x05\0\x02\x03\0\0\x0cchat-reque\
st\x02\x03\0\0\x0dchat-response\x02\x03\0\0\x0bhttp-config\x02\x03\0\0\x0dhttp-r\
esponse\x02\x03\0\0\x0cstream-chunk\x01B\x14\x02\x03\x02\x01\x01\x04\0\x0cchat-r\
equest\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0dchat-response\x03\0\x02\x02\x03\x02\x01\
\x03\x04\0\x0bhttp-config\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x0dhttp-response\x03\
\0\x06\x02\x03\x02\x01\x05\x04\0\x0cstream-chunk\x03\0\x08\x01j\x01\x05\x01s\x01\
@\x01\x07request\x01\0\x0a\x04\0\x0fprepare-request\x01\x0b\x01j\x01\x03\x01s\x01\
@\x01\x08response\x07\0\x0c\x04\0\x0eparse-response\x01\x0d\x01k\x09\x01j\x01\x0e\
\x01s\x01@\x01\x05chunks\0\x0f\x04\0\x12parse-stream-chunk\x01\x10\x04\0\x20ai-m\
essenger:llm/llm@0.0.1-alpha\x05\x06\x04\0(ai-messenger:llm/llm-adapter@0.0.1-al\
pha\x04\0\x0b\x11\x01\0\x0bllm-adapter\x03\0\0\0G\x09producers\x01\x0cprocessed-\
by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
